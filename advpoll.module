<?php
// $Id$

/**
 * @file
 * Advanced Poll - a sophisticated polling module for voting, elections, and group decision-making.
 */

define('ADVPOLL_MAXCHOICES', 0);
define('ADVPOLL_RUNTIME', 0);
define('ADVPOLL_ELECTORAL_LIST', 0);
define('ADVPOLL_SHOWVOTES', 1);
// Options: always, aftervote, or afterclose.
define('ADVPOLL_VIEW_RESULTS', 'aftervote');

/**
 * Implementation of hook_access().
 */
function advpoll_access($op, $node) {
  global $user;

  if ($op == 'create') {
    return user_access('create polls');
  }
  if ($op == 'update') {
    if (user_access('edit polls') || ($node->uid == $user->uid && user_access('edit own polls'))) {
      return TRUE;
    }
  }
}

/**
 * Implementation of hook_block().
 */
function advpoll_block($op = 'list') {
  switch ($op) {
    case 'list':
      $blocks['mostrecent']['info'] = t('Latest poll');
      return $blocks;
    case 'view':
      $block['subject'] = t('Latest poll');
      $block['content'] = theme('advpoll_block_mostrecent');
      return $block;
  }
}

/**
 * Content of the block, as returned by advpoll_block('view').
 */
function theme_advpoll_block_mostrecent() {
  $node = advpoll_mostrecent();
  $output = '';
  if ($node) {
    $output .= '<h3>'. check_plain($node->title) .'</h3>';  
    $output .= drupal_render($node->content);
    if ($node->voted) {
      $output .= '<p>'. l(t('Older polls'), 'polls', array('class' => 'old-polls', 'title' => t('View the list of polls on this site.'))) .'</p>'; 
    }
  }
  return $output;
}

function advpoll_mostrecent() {
  $result = db_query('SELECT MAX(n.nid) AS nid FROM {node} n INNER JOIN {advpoll} p ON p.nid = n.nid WHERE n.status = 1 AND p.active=1');
  $poll = db_fetch_object($result);
  // The nid will be NULL if there are no active polls.
  if ($poll->nid) {
    $node = advpoll_view(node_load($poll->nid), FALSE, FALSE);
  }
  return $node;
}

function advpoll_page() {
  // List all polls
  $sql = "SELECT n.nid, n.title, p.active, n.created, c.value AS votes FROM {node} n INNER JOIN {advpoll} p ON n.nid = p.nid INNER JOIN {votingapi_cache} c ON n.nid = c.content_id WHERE n.status = 1 AND c.tag = '_advpoll' AND c.function='total_votes' AND c.content_type='advpoll' GROUP BY n.nid, n.title, p.active, n.created, c.value ORDER BY n.created DESC";
  $sql = db_rewrite_sql($sql);
  $result = pager_query($sql, 15);
  $output = '<ul>';
  while ($node = db_fetch_object($result)) {
    $output .= '<li>'. l($node->title, "node/$node->nid") .' - '. format_plural($node->votes, '1 vote', '@count votes') .' - '. (_advpoll_is_active($node) ? t('open') : t('closed')) .'</li>';
  }
  $output .= '</ul>';
  $output .= theme('pager', NULL, 15);
  return $output;
}

/**
 * Implementation of VotingAPI's hook_calculate.
 * 
 * Recalculate results whenever a vote is added or removed.
 */
function advpoll_votingapi_calculate(&$results, $votes, $content_type, $content_id) {
  // Make sure it's an Advanced Poll content type
  if ($content_type == 'advpoll') {
    // Don't load the node from cache in case the mode or algorithm changed.
    $node = node_load($content_id, NULL, TRUE);
    $mode = _advpoll_get_mode($node->type);
    $function = 'advpoll_calculate_results_'. $mode;
    if (function_exists($function)) {
      $function($results, $votes, $node);
    }
    cache_clear_all();
  }
}

/**
 * Implementation of hook_delete().
 */
function advpoll_delete($node) {
  db_query("DELETE FROM {advpoll} WHERE nid = %d", $node->nid);
  db_query("DELETE FROM {advpoll_choices} WHERE nid = %d", $node->nid);
  db_query("DELETE FROM {advpoll_electoral_list} WHERE nid = %d", $node->nid);

  // TODO: These should be converted to a votingapi method eventually.
  db_query("DELETE FROM {votingapi_vote} WHERE content_id = %d AND content_type='advpoll'", $node->nid);
  db_query("DELETE FROM {votingapi_cache} WHERE content_id = %d AND content_type='advpoll'", $node->nid);
}

/**
 * Implementation of hook_form().
 *
 * This hook displays the form necessary to create/edit the poll.
 */
function advpoll_form($node, $form_values = NULL) {
  $mode = _advpoll_get_mode($node->type);
  $type = node_get_types('type', $node);

  // Only add javascript once, even if _form is called multiple times.
  static $add_js;
  if (!$add_js) {
    // Pass translatable strings
    drupal_add_js(array('advPoll' => array('remove' => t('Remove'), 'addChoice' => t('Add choice'), 'noLimit' => t('No limit'))), 'setting');
    drupal_add_js(drupal_get_path('module', 'advpoll') .'/advpoll-form.js', 'module');
    drupal_add_css(drupal_get_path('module', 'advpoll') .'/advpoll.css', 'module');
    $add_js = true;
  }

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => check_plain($type->title_label),
    '#required' => TRUE,
    '#default_value' => $node->title,
  );

  $form['body_filter']['body'] = array(
    '#type' => 'textarea',
    '#title' => check_plain($type->body_label),
    '#required' => FALSE,
    '#default_value' => $node->body,
  );
  
  $form['body_filter']['format'] = filter_form($node->format);

  if (isset($form_values)) {
    $choices = $form_values['choices'];
    if ($form_values['morechoices']) {
      $choices *= 2;
    }
  }
  else {
    $choices = max(2, count($node->choice)? count($node->choice) : 5);
  }

  $form['choices'] = array(
    '#type' => 'hidden',
    '#value' => $choices,
  );

  // Advanced Poll choices
  $form['choice'] = array(
    '#type' => 'fieldset',
    '#title' => t('Poll choices'),
    '#collapsible' => TRUE,
    '#prefix' => '<div class="poll-form">',
    '#suffix' => '</div>',
    '#tree' => TRUE,
    '#weight' => 1,
  );
  
  $form['choice']['morechoices'] = array(
    '#type' => 'checkbox',
    '#title' => t('Need more choices'),
    '#value' => 0,
    '#parents' => array('morechoices'), // Don't pollute $form['choice']
    '#prefix' => '<div id="morechoices">',
    '#suffix' => '</div>',
    '#description' => t("If the amount of boxes above isn't enough, check this box and click the Preview button below to add some more."),
    '#weight' => 1
  );

  for ($a = 1; $a <= $choices; $a++) {
    $form['choice'][$a]['label'] = array(
      '#type' => 'textfield',
      '#title' => t('Choice %n', array('%n' => $a)),
      '#default_value' => $node->choice[$a]['label'],
      '#attributes' => array('class' => 'choices'),
    );
  }

  $form['settings'] = array(
    '#type' => 'fieldset',
    '#title' => t('Poll settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#weight' => 2,
    '#tree' => TRUE,
  );

  $max_choice_list = array();
  for ($i = 0; $i <= $choices; $i++) {
    $max_choice_list[$i] = ($i == 0 ? t('No limit') : $i);
  }

  $form['settings']['maxchoices'] = array(
    '#type' => 'select',
    '#title' => t('Maximum choices'),
    '#default_value' => ($node->maxchoices? $node->maxchoices : variable_get('advpoll_maxchoices_'. $type->type, ADVPOLL_MAXCHOICES)),
    '#options' => $max_choice_list,
    '#DANGEROUS_SKIP_CHECK' => true, // Allow jQuery to add new options
    '#description' => t('Limits the total number of choices voters may select.')
  );

  $voting_algorithms = advpoll_algorithms($mode);
  
  if (count($voting_algorithms) > 1) {
    $form['settings']['algorithm'] = array(
      '#type' => 'select',
      '#title' => t('Algorithm'),
      '#options' => $voting_algorithms,
      '#default_value' => $node->algorithm ? $node->algorithm : variable_get('advpoll_algorithm_'. $type->type, key($voting_algorithms)),
      '#description' => t('Voting algorithm to use to calculate the winner.'),
    );
  }
  
  $form['settings']['close'] = array(
    '#type' => 'checkbox',
    '#title' => t('Close poll'),
    '#description' => t('When a poll is closed users may no longer vote on it.'),
    '#default_value' => isset($node->active) ? !$node->active : 0,
  );

  $default_startdate = '';
  $default_enddate = '';
  $time = format_date(time(), 'custom', 'Y-m-d H:i:s O');
  // Specify default dates if default duration is set and we are creating a node.
  if (variable_get('advpoll_runtime_'. $type->type, FALSE) && !isset($node->nid)) {
    $default_startdate = $time;
    $default_enddate = format_date(time() + variable_get('advpoll_runtime_'. $type->type, ''), 'custom', 'Y-m-d H:i:s O');
  }
  
  $form['settings']['startdate'] = array(
    '#type' => 'textfield',
    '#title' => t('Starting date'),
    '#description' => t('The date that the poll opens. Format: %time. Leave blank if you want the poll to open now.', array('%time' => $time)),
    '#size' => 25,
    '#maxlength' => 25,
    '#default_value' => $node->startdate ? format_date($node->startdate, 'custom', 'Y-m-d H:i:s O') : $default_startdate,
  );
  
  $form['settings']['enddate'] = array(
    '#type' => 'textfield',
    '#title' => t('Ending date'),
    '#description' => t('The date that the poll closes. Format: %time. Leave blank if you do not want the poll to close automatically.', array('%time' => $time)),
    '#size' => 25,
    '#maxlength' => 25,
    '#default_value' => $node->enddate ? format_date($node->enddate, 'custom', 'Y-m-d H:i:s O') : $default_enddate,
  );
  
  // Settings available for users with 'administer polls' permission.
  $default_uselist = isset($node->uselist) ? $node->uselist : variable_get('advpoll_electoral_list_'. $type->type, ADVPOLL_ELECTORAL_LIST);
  $default_showvotes = isset($node->showvotes) ? $node->showvotes : variable_get('advpoll_showvotes_'. $type->type, ADVPOLL_SHOWVOTES);
  if (user_access('administer polls')) {
    $form['settings']['admin_note'] = array(
      '#value' => '<div id="edit-settings-admin-note" class="description">'. t('The settings below are only available for users with the <em>administer polls</em> permission.') .'</div>',
    );
    $form['settings']['uselist'] = array(
      '#type' => 'checkbox',
      '#title' => t('Restrict voting to electoral list'),
      '#description' => t('If enabled, a list of eligible voters will be created and only that group will be able to vote in the poll.'),
      '#default_value' => $default_uselist,
    );
  
    $form['settings']['showvotes'] = array(
      '#type' => 'checkbox',
      '#title' => t('Show individual votes'),
      '#description' => t('Users with the appropriate permissions will be able to see how each person voted.'),
      '#default_value' => $default_showvotes,
    );
    
    // Only show when editing a poll, not creating.
    if ($node->nid) {
      $form['settings']['reset'] = array(
        '#type' => 'button',
        '#value' => t('Reset votes'),
      );
    }
  }
  else {
    // Just pass the values for users without the 'administer polls' permission.
    $form['settings']['uselist'] = array(
      '#type' => 'value',
      '#default_value' => $default_uselist,
    );
  
    $form['settings']['showvotes'] = array(
      '#type' => 'value',
      '#default_value' => $default_showvotes,
    );
  }
  
  $form['#multistep'] = TRUE;

  return $form;
}

/**
 * Implementation of hook_form_alter().
 */
function advpoll_form_alter($form_id, &$form) {
  if ($form_id == 'node_type_form' && isset($form['identity']['type'])) {
    $node_type = $form['old_type']['#value'];
    // Display poll settings if this is an advpoll content type.
    if ($form['module']['#value'] == 'advpoll') {
      $form['advpoll'] = array(
        '#type' => 'fieldset',
        '#title' => t('Poll settings'),
        '#collapsible' => TRUE,
      );
      
      $form['advpoll']['advpoll_maxchoices'] = array(
        '#type' => 'select',
        '#title' => t('Default maximum choices'),
        '#options' => array(0 => t('No limit')) + drupal_map_assoc(array(1, 2, 3, 4, 5)),
        '#default_value' => variable_get('advpoll_maxchoices_'. $node_type, ADVPOLL_MAXCHOICES),
        '#description' => t('The default number of maximum choices for new polls. This setting can be overridden on the poll edit page.'),
      );
      
      $mode = _advpoll_get_mode($node_type);
      $voting_algorithms = advpoll_algorithms($mode);
      
      if (count($voting_algorithms) > 1) {
        $form['advpoll']['advpoll_algorithm'] = array(
          '#type' => 'select',
          '#title' => t('Default algorithm'),
          '#options' => $voting_algorithms,
          '#default_value' => variable_get('advpoll_algorithm_'. $node_type, key($voting_algorithms)),
          '#description' => t('Default voting algorithm for calculating the winner.'),
        );
      }
      
      $form['advpoll']['advpoll_runtime'] = array(
        '#type' => 'select',
        '#title' => t('Default duration'),
        '#default_value' => variable_get('advpoll_runtime_'. $node_type, ADVPOLL_RUNTIME),
        '#options' => array(0 => t('Unlimited')) + drupal_map_assoc(array(86400, 172800, 345600, 604800, 1209600, 1814400, 2419200, 4838400, 9676800, 31536000), 'format_interval'),
        '#description' => t('The date the poll was created is used as start date for the default duration. This setting can be overridden on the poll edit page.'),
      );

      $form['advpoll']['advpoll_electoral_list'] = array(
        '#type' => 'checkbox',
        '#title' => t('Use electoral list by default'),
        '#description' => t('Use an electoral list by default for new polls. Users with the <em>administer polls</em> permission will be able to override this setting.'),
        '#default_value' => variable_get('advpoll_electoral_list_'. $node_type, ADVPOLL_ELECTORAL_LIST),
      );
      
      $form['advpoll']['advpoll_showvotes'] = array(
        '#type' => 'checkbox',
        '#title' => t('Show individual votes by default'),
        '#description' => t('Let users with appropriate permissions see how each person voted by default for new polls. Users with the <em>administer polls</em> permission will be able to override this setting.'),
        '#default_value' => variable_get('advpoll_showvotes_'. $node_type, ADVPOLL_SHOWVOTES),
      );
    
      $view_results = array(
        'always' => t('Always'),
        'aftervote' => t('After user has voted'),
        'afterclose' => t('After voting has closed'),
      );
    
      $form['advpoll']['advpoll_view_results'] = array(
        '#type' => 'radios',
        '#title' => t('Display results'),
        '#description' => t('Determines when users may view the results of the poll.'),
        '#default_value' => variable_get('advpoll_view_results_'. $node_type, ADVPOLL_VIEW_RESULTS),
        '#options' => $view_results,
      );
    }
  }
}

/**
 * Implementation of hook_help().
 */
function advpoll_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('A sophisticated polling module for voting, elections, and group decision-making.');
    default:
  }
}

/**
 * Implementation of hook_load().
 *
 * Load the votes and poll-specific data into the node object.
 */
function advpoll_load($node) {
  global $user;
  $poll = db_fetch_object(db_query("SELECT * FROM {advpoll} WHERE nid = %d", $node->nid));
  $result = db_query("SELECT vote_offset, label FROM {advpoll_choices} WHERE nid = %d ORDER BY vote_offset", $node->nid);
  while ($choice = db_fetch_array($result)) {
    $poll->choice[$choice['vote_offset']] = $choice;
  }
  $poll->choices = count($poll->choice);

  $result = db_query("SELECT value FROM {votingapi_cache} where content_type='advpoll' AND content_id=%d AND tag='_advpoll' AND function='total_votes'", $node->nid);
  if (db_num_rows($result) > 0) {
    $cache = db_fetch_object($result);
    $poll->votes = $cache->value;
  }
  else {
    $poll->votes = 0;
  }

  list($poll->voted, $poll->cancel_vote) = _advpoll_user_voted($node->nid);
  return $poll;
}

/**
 * Check if a user has voted on a poll.
 *
 * @return Array indicating if user voted and, if so, if the vote is cancellable.
 */
function _advpoll_user_voted($nid) {
  global $user;
  $voted = FALSE;
  $cancel_vote = FALSE;

  if ($user->uid) {
    // Voter is logged in.
    $voted = (count(votingapi_get_user_votes('advpoll', $nid)) > 0);
    if ($voted) {
      $cancel_vote = TRUE;
    }
  }
  else {
    // Voter is anonymous.

    // TODO: add options to check cookie rather than IP for anonymous votes.

    // Check if there is already an anonymous vote for this IP.
    $host =  $_SERVER['REMOTE_ADDR'] . ($_SERVER['HTTP_X_FORWARDED_FOR'] ? '-'. $_SERVER['HTTP_X_FORWARDED_FOR'] : '');
    $result = db_query("SELECT value FROM {votingapi_vote} WHERE content_id=%d AND content_type='advpoll' AND hostname='%s' AND uid=0", $nid, $host);
    if (db_num_rows($result) > 0) {
      $voted = TRUE;
      $cancel_vote = TRUE;
    }
  }
  return array($voted, $cancel_vote);
}

/**
 * Implementation of hook_menu().
 */
function advpoll_menu($may_cache) {
  global $user;

  // Load the modes in here instead of _init() toprofit from caching,
  // as recommended by http://api.drupal.org/api/head/function/hook_init.
  $modes = _advpoll_list_modes();

  $items = array();

  if ($may_cache) {
    $items[] = array(
      'path' => 'advpoll/cancel',
      'title' => t('Cancel'),
      'callback' => 'advpoll_cancel',
      'access' => user_access('cancel own vote'),
      'type' => MENU_CALLBACK
    );
    
    $items[] = array(
      'path' => 'polls',
      'title' => t('Advanced Polls'),
      'callback' => 'advpoll_page',
      'access' => user_access('access content'),
      'type' => MENU_SUGGESTED_ITEM,
    );
  }
  else {
    // Use Poll modules stylesheet, no need to duplicate at this point.
    // We put this in !$may_cache so it's only added once per request.
    drupal_add_css(drupal_get_path('module', 'poll') .'/poll.css');
    
    // Need to be able to extract the nid
    if (arg(0) == 'node' && is_numeric(arg(1))) {
      $nid = arg(1);
      $node = node_load($nid);
      // Make sure we're on the actual poll node's page
      if (strstr($node->type, 'advpoll_') == 0) {
        // Show the results tab
        if (_advpoll_is_active($node) && !$node->voted && _advpoll_can_view_results($node)) {
          $items[] = array(
            'path' => 'node/'. $nid .'/results',
            'title' => t('Results'),
            'callback' => 'advpoll_results',
            'access' => user_access('access content'),
            'weight' => 3,
            'type' => MENU_LOCAL_TASK,
          );
        }

        // Show the votes tab
        if ($node->showvotes) {
          $items[] = array(
            'path' => 'node/'. $nid .'/votes',
            'title' => t('Votes'),
            'callback' => 'advpoll_tab_votes',
            'access' => user_access('inspect all votes'),
            'weight' => 3,
            'type' => MENU_LOCAL_TASK,
          );
        }

        // Show electoral list tab if using the functionality
        if ($node->uselist) {
          $items[] = array(
            'path' => 'node/'. $nid .'/electoral_list',
            'title' => t('Electoral list'),
            'callback' => 'advpoll_tab_electoral_list',
            'access' => user_access('access electoral list'),
            'weight' => 3,
            'type' => MENU_LOCAL_TASK,
          );

          // Allow voters to be removed
          $items[] = array(
            'path' => 'node/'. $nid .'/remove',
            'callback' => 'advpoll_remove_voter',
            'access' => user_access('administer polls'),
            'weight' => 3,
            'type' => MENU_CALLBACK,
          );
        }

        // Allow votes to be reset
        $items[] = array(
          'path' => 'node/'. $nid .'/reset',
          'callback' => 'drupal_get_form',
          'callback arguments' => 'advpoll_reset_confirm',
          'access' => user_access('administer polls'),
          'weight' => 3,
          'type' => MENU_CALLBACK,
        );
      }
    }
  }

  return $items;
}

/**
 * Display the electoral list tab.
 */
function advpoll_tab_electoral_list() {
  if ($node = node_load(arg(1))) {
    if (!$node->uselist) {
      drupal_not_found();
      return;
    }
    drupal_set_title(check_plain($node->title));
    
    if (user_access('administer polls')) {
      $output .= drupal_get_form('advpoll_electoral_list_form', $node->nid);
    }

    $output .= '<p>'. t('This table lists all the eligible voters for this poll.') .'</p>';

    $header[] = array('data' => t('Voter'), 'field' => 'u.name');

    $result = pager_query("SELECT u.uid, u.name FROM {advpoll_electoral_list} el LEFT JOIN {users} u ON el.uid = u.uid WHERE el.nid = %d" . tablesort_sql($header), 20, 0, NULL, $node->nid);
    $eligible_voters = array();
    while ($voter = db_fetch_object($result)) {
      $temp = array(
        theme('username', $voter),
      );

      if (user_access('administer polls')) {
        $temp[] = l(t('remove'), 'node/'. $node->nid .'/remove/'. $voter->uid);
      }

      $eligible_voters[] = $temp;
    }
    $output .= theme('table', $header, $eligible_voters);
    $output .= theme('pager', NULL, 20, 0);
    print theme('page', $output);
  }
  else {
    drupal_not_found();
  }
}

function advpoll_electoral_list_form($nid) {
  $form['electoral_list'] = array(
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#title' => t('Administer electoral list'),
    '#collapsible' => TRUE,
    '#weight' => 2,
  );

  $form['electoral_list']['add_user'] = array(
    '#type' => 'textfield',
    '#title' => t('Add user'),
    '#size' => 40,
    '#description' => t('Add an individual user to the electoral list.'),
  );
  
  // Enable autocompletion if user has required permission.
  if (user_access('access user profiles')) {
    $form['electoral_list']['add_user']['#autocomplete_path'] = 'user/autocomplete';
  }

  // List all roles with "vote on polls" permission, but don't include anonymous users.
  $result = db_query("SELECT r.name, r.rid FROM {role} r LEFT JOIN {permission} p ON p.rid=r.rid WHERE p.perm LIKE '%vote on polls%' AND r.rid != 1 ORDER BY r.name");
  $role_options = array(0 => t('(Select a role)'));
  while ($role = db_fetch_object($result)) {
    $role_options[$role->rid] = $role->name;
  }

  $form['electoral_list']['add_role'] = array(
    '#type' => 'select',
    '#title' => t('Add users by role'),
    '#description' => t('Only roles that have the "vote on polls" permission are listed.'),
    '#options' => $role_options,
  );

  $form['electoral_list']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Add to electoral list'),
  );

  $form['electoral_list']['reset'] = array(
    '#type' => 'button',
    '#value' => t('Clear electoral list'),
  );

  $form['nid'] = array('#type' => 'hidden', '#value' => $nid);
  return $form;
}

/**
 * Remove an individual voter from the electoral list.
 */
function advpoll_remove_voter() {
  $nid = arg(1);
  $uid = arg(3);
  if ($uid && $node = node_load($nid)) {
    $result = db_query('SELECT name FROM {users} WHERE uid=%d', $uid);
    if (db_num_rows($result) > 0) {
      $user = db_fetch_object($result);
      db_query('DELETE FROM {advpoll_electoral_list} WHERE nid=%d AND uid=%d', $nid, $uid);
      drupal_set_message(t('%user removed from the electoral list.', array('%user' => $user->name)));
    }
    else {
      drupal_set_message(t('No user found with a uid of %uid.', array('%uid' => $uid)));
    }

  }
  drupal_goto('node/'. $node->nid .'/electoral_list');
}

/**
 * Validate changes to the electoral list.
 */
function advpoll_electoral_list_form_validate($form_id, $form_values) {
  if ($form_values['op'] == t('Reset electoral list')) {
    if (user_access('administer polls')) {
      db_query('DELETE FROM {advpoll_electoral_list} WHERE nid=%d', $form_values['nid']);
      drupal_set_message(t('Electoral list cleared.'));
      return;
    }
  }

  $add_user = $form_values['electoral_list']['add_user'];
  if ($add_user) {
    // Check that the user exists
    $result = db_query("SELECT uid FROM {users} WHERE name='%s'", $add_user);
    if (db_num_rows($result) == 0) {
      form_set_error('electoral_list][add_user', t('User %user does not exist.', array('%user' => $add_user)));
      return FALSE;
    }
  }
}

/**
 * Submit changes to the electoral list.
 */
function advpoll_electoral_list_form_submit($form_id, $form_values) {
  $add_user = $form_values['electoral_list']['add_user'];
  if ($add_user) {
    db_query("REPLACE INTO {advpoll_electoral_list} (nid, uid) SELECT '%d', u.uid FROM users u WHERE u.name = '%s'", $form_values['nid'], $add_user);
    drupal_set_message(t('%user added to electoral list.', array('%user' => $add_user)));
  }

  $add_role = $form_values['electoral_list']['add_role'];
  if ($add_role) {
    // Get the current electoral list.
    $result = db_query('SELECT uid FROM {advpoll_electoral_list} WHERE nid=%d', $form_values['nid']);
    $current_list = array(0);
    while ($user = db_fetch_object($result)) {
      $current_list[] = $user->uid;
    }

    $user_in_string = implode(',', $current_list);
    // Check if all authenticated users should be added.
    $result = db_fetch_object(db_query("SELECT COUNT(*) AS hit FROM {role} r WHERE r.name = 'authenticated user' AND r.rid = %d", $add_role));
    if ($result->hit) {
      // Special case: any authenticated user can vote.
      // Add all current users to electoral list.
      $result = db_query("INSERT INTO {advpoll_electoral_list} (nid, uid) SELECT '%d', u.uid FROM {users} u WHERE u.uid NOT IN('%s')", $form_values['nid'], $user_in_string);
    }
    else {
      // Insert new users into the electoral_list based on the role chosen.
      $result = db_query("INSERT INTO {advpoll_electoral_list} (nid, uid) SELECT '%d', u.uid FROM {users} u LEFT JOIN {users_roles} ur ON u.uid = ur.uid WHERE ur.rid = %d AND u.uid NOT IN('%s')", $form_values['nid'], $add_role, $user_in_string);
    }
    drupal_set_message(format_plural(db_affected_rows($result), 'Added <em>1</em> user to the electoral list.', 'Added @count users to the electoral list.'));

  }
}

/**
 * Display the votes tab.
 */
function advpoll_tab_votes() {
  if ($node = node_load(arg(1))) {
    if (!$node->showvotes) {
      // Advanced Poll is set to not allow viewing of votes
      drupal_not_found();
      return;
    }
    drupal_set_title(check_plain($node->title));
    $output = t('This table lists all the recorded votes for this poll. If anonymous users are allowed to vote, they will be identified by the IP address of the computer they used when they voted.');

    $header[] = array('data' => t('Visitor'), 'field' => 'u.name');
    $header[] = array('data' => t('Vote'), '');

    $result = pager_query("SELECT v.value, v.uid, v.hostname, v.tag, u.name FROM {votingapi_vote} v LEFT JOIN {users} u ON v.uid = u.uid WHERE v.content_type='advpoll' AND v.content_id = %d". tablesort_sql($header), 20, 0, NULL, $node->nid);
    $rows = array();
    while ($vote = db_fetch_object($result)) {
      $key = $vote->uid? $vote->uid : $vote->hostname;
      $rows[$key]['name'] = $vote->name ? theme('username', $vote) : check_plain($vote->hostname);
      if ($node->type == 'advpoll_ranking') {
        // Need two dimensional results (if equal rankings are allowed)
        $rows[$key]['votes'][$vote->value][] = _advpoll_choice_markup($node->choice[$vote->tag]['label'], $node->format, false);
      }
      else {
        // Just need one dimensional results
        $rows[$key]['votes'][] = _advpoll_choice_markup($node->choice[$vote->tag]['label'], $node->format, false);
      }
    }
    
    $separators = array('advpoll_ranking' => ' > ', 'advpoll_binary' => ', ');

    // Create strings out of each vote
    $results = array();

    foreach ($rows as $key => $container) {
      $ranking = $container['votes'];
      asort($ranking);
      $rankings = array();
      if ($node->type == 'advpoll_ranking') {
        // Include support for multiple choices having the same ranking
        foreach ($ranking as $vote => $choices) {
          $rankings[$vote] = implode(' = ', $choices);
        }
      }
      else {
        // Just copy the previous array
        $rankings = $ranking;
      }
      ksort($rankings);
      $results[$key]['name'] = $rows[$key]['name'];
      $results[$key]['vote'] = implode($separators[$node->type], $rankings);
    }

    $output .= theme('table', $header, $results);
    $output .= theme('pager', NULL, 20, 0);
    print theme('page', $output);
  }
  else {
    drupal_not_found();
  }
}

/**
 * Helper function to abstract view results checking.
 */
function _advpoll_can_view_results($node) {
  $view_results = variable_get('advpoll_view_results_'. $node->type, ADVPOLL_VIEW_RESULTS);
  return (!_advpoll_is_active($node)  // Node is closed
        || ($node->voted && $view_results == 'aftervote') // User voted
        || ($view_results == 'always')); // All can view
}

/**
 * Implementation of hook_node_info().
 */
function advpoll_node_info() {
  $modes = _advpoll_list_modes();
  $info = array();
  foreach ($modes as $mode) {
    $info['advpoll_'. $mode['name']] = array(
      'name' => t('@name poll', array('@name' => $mode['name_label'])),
      'module' => 'advpoll',
      'description' => $mode['description'],
      'title_label' => t('@name question', array('@name' => $mode['name_label'])),
      'body_label' => t('Description'),
    );
  }
  return $info;
}

/**
 * Implementation of hook_perm().
 */
function advpoll_perm() {
  return array('create polls', 'edit polls', 'edit own polls', 'vote on polls', 'cancel own vote', 'administer polls', 'inspect all votes', 'access electoral list');
}

/**
 * Helper function to display 'cancel vote' button if user has voted.
 */
function advpoll_cancel_form($nid) {
  $form['#action'] = url("advpoll/cancel/$nid");
  $form['submit'] = array('#type' => 'submit', '#value' => t('Cancel your vote'));
  return $form;  
}

/**
 * Implementation of hook_update().
 *
 * This is called upon node edition.
 */
function advpoll_update($node) {

  db_query("UPDATE {advpoll} SET active = %d, maxchoices = %d, algorithm = '%s', uselist = %d, showvotes = %d, startdate = '%s', enddate = '%s' WHERE nid = %d", !$node->settings['close'], $node->settings['maxchoices'], $node->settings['algorithm'], $node->settings['uselist'], $node->settings['showvotes'], $node->settings['startdate'] ? strtotime($node->settings['startdate']) : 0, $node->settings['enddate'] ? strtotime($node->settings['enddate']) : 0, $node->nid);

  _advpoll_insert_choices($node->nid);
  votingapi_recalculate_results('advpoll', $node->nid);
}


/**
 * Helper function to check if a poll is active.
 */
function _advpoll_is_active($node, $return_status = FALSE) {
  $active = TRUE;
  $status = 'open';
  $startdate = $node->startdate;
  $enddate = $node->enddate;

  // Check if poll is closed.
  if (!$node->active) {
    $active = FALSE;
    $status = 'closed';
  }

  if ($active && $startdate > 0) {
    // Check that startdate is in the past.
    if (!$active = time() >= $startdate) {
      $status = 'pending';
    }
  }

  if ($active && ($enddate > 0)) {
    // Check that enddate is in the future.
    if (!$active = time() < $enddate) {
      $status = 'passed';
    }
  }
  
  if ($return_status) {
    return $status;  
  }
  else {
    return $active;  
  }  
}

function _advpoll_insert_choices($nid) {
  db_query('DELETE FROM {advpoll_choices} WHERE nid = %d', $nid);
  // Start at one rather than 0 due to Drupal FormAPI
  $i = 1;
  foreach ($_POST['choice'] as $choice) {
    if ($choice['label'] != '') {
      db_query("INSERT INTO {advpoll_choices} (nid, label, vote_offset) VALUES (%d, '%s', %d)", $nid, $choice['label'], $i++);
    }
  }
}

function _advpoll_get_mode($node_type) {
  if ($node_type) {
    $mode = explode('advpoll_', $node_type, 2);
    return $mode[1];
  }
  else {
    drupal_set_message(t('No mode specified for this content type'), 'error');
    return '';
  }
}

/**
 * Implementation of hook_insert().
 *
 * This is called upon node creation.
 */
function advpoll_insert($node) {
  $mode = _advpoll_get_mode($node->type);
  db_query("INSERT INTO {advpoll} (nid, mode, uselist, active, maxchoices, algorithm, showvotes, startdate, enddate) VALUES (%d, '%s', %d, %d, %d, '%s', %d, '%s', '%s')", $node->nid, $mode, $node->settings['uselist'], !$node->settings['close'], $node->settings['maxchoices'], $node->settings['algorithm'], $node->settings['showvotes'], $node->settings['startdate'] ? strtotime($node->settings['startdate']) : 0, $node->settings['enddate'] ? strtotime($node->settings['enddate']) : 0);

  // Insert the choices
  _advpoll_insert_choices($node->nid);
}

/**
 * Callback to display a reset votes confirmation form.
 */ 
function advpoll_reset_confirm() {
  global $form_values;
  $edit = $form_values['edit'];
  $edit['nid'] = $edit['nid']? $edit['nid'] : arg(1);
  $node = node_load($edit['nid']);

  $form['nid'] = array('#type' => 'value', '#value' => $node->nid);
  $output = confirm_form($form,
    t('Are you sure you want to reset the votes for %title?',
    array('%title' => $node->title)),
    'node/'. $node->nid,
    t('This action cannot be undone.'),
    t('Reset votes'),
    t('Cancel'));
  return $output;
}

/**
 * Reset votes once the confirmation is given.
 */
function advpoll_reset_confirm_submit($form_id, $form_values) {
  if ($form_values['confirm']) {
    $nid = arg(1);
    if ($node = node_load($nid)) {
      // Delete any votes for the poll
      db_query("DELETE FROM {votingapi_vote} WHERE content_type='advpoll' AND content_id = %d", $node->nid);
      votingapi_recalculate_results('advpoll', $node->nid);
      drupal_set_message('Votes have been reset.');
      drupal_goto('node/'. $node->nid);
    }
  }

  return '';
}

/**
 * Implementation of hook_validate().
 */
function advpoll_validate(&$node) {
  global $form_values;
  if ($form_values['op'] == t('Reset votes')) {
    drupal_goto('node/'. $node->nid .'/reset');
  }
  else {
    // Use form_set_error for any errors
    $node->choice = array_values($node->choice);

    // Start keys at 1 rather than 0
    array_unshift($node->choice, '');
    unset($node->choice[0]);

    // Check for at least two choices
    $realchoices = 0;
    foreach ($node->choice as $i => $choice) {
      if ($choice['label'] != '') {
        $realchoices++;
      }
    }

    if ($realchoices < 2) {
      form_set_error("choice][$realchoices][label", t('You must fill in at least two choices.'));
    }

    /* Validate maxchoices since it has #DANGEROUS_SKIP_CHECK set to true */
    if ($node->settings['maxchoices'] < 0) {
      form_set_error('settings][maxchoices]', t('Maximum choices must be a non-negative integer.'));
    }

    if ($node->settings['maxchoices'] > count($node->choice)) {
      form_set_error('settings][maxchoices]', t('Maximum choices cannot be larger than the number of choices submitted.'));
    }
    
    // Validate dates
    if (!empty($node->settings['startdate']) && strtotime($node->settings['startdate']) <= 0) {
      form_set_error('settings][startdate', t('You have to specify a valid starting date.'));
    }
    if (!empty($node->settings['enddate']) && strtotime($node->settings['enddate']) <= 0) {
      form_set_error('settings][enddate', t('You have to specify a valid ending date.'));
    }
    if (!empty($node->settings['enddate']) && $node->settings['enddate'] < $node->settings['startdate']) {
      form_set_error('settings][enddate', t('Ending date cannot be before the starting date.'));
    }
  }
}

function advpoll_submit(&$node) {
  $node->choice = array_values($node->choice);
  // Start keys at 1 rather than 0
  array_unshift($node->choice, '');
  unset($node->choice[0]);
}

/**
 * Implementation of hook_view().
 */
function advpoll_view($node, $teaser = FALSE, $page = FALSE) {
  $status = _advpoll_is_active($node, TRUE);
  
  if ($node->in_preview) {
    // Previewing a node, so display voting form instead of results.
    $mode = _advpoll_get_mode($node->type);
    $node->content['poll'] = array(
      '#weight' => 1,
      '#value' => drupal_get_form('advpoll_voting_'. $mode .'_form', $node, $teaser, $page),
    );
  }
  else if (!$node->voted && arg(2) != 'results' && ($status == 'open' || $status == 'pending')) {
    // User hasn't voted, we're not on the results tab and poll is open or opening in the future.
    $node->content['poll'] = array(
      '#weight' => 1,
      '#value' => drupal_get_form('advpoll_voting_'. $node->mode .'_form', $node, $teaser, $page, $status),
    );
    static $addjs = TRUE;
    if ($addjs) {
      // Add javascript for posting voting forms with Ajax
      drupal_add_js(array('advPoll' => array('vote' => t('Vote'))), 'setting');
      drupal_add_js(drupal_get_path('module', 'advpoll') .'/advpoll-vote.js', 'module');
      drupal_add_js(drupal_get_path('module', 'advpoll') .'/jquery.form.js', 'module');
      $addjs = FALSE;
    }
  }
  else {
    // Show results (the user has voted, poll is closed or poll has passed).
    $node->content['poll'] = array(
      '#weight' => 1,
      '#value' => advpoll_view_results($node, $teaser, $page)
    );  
  }
  return node_prepare($node, $teaser);
}

function _advpoll_block_resultslink($node) {
  return array(
    'title' => t('Results'),
    'href' => 'node/'. $node->nid .'/results',
    'attributes' => array('title' => t('View the current poll results.')),
  );
}

function theme_advpoll_results($title, $results, $votes, $links, $nid, $voted, $cancel_vote) {
  $output = '<div class="poll">';
  if ($results) {
    $output .= $results;
    $output .= '<div class="total">'. t('Total votes: %votes', array('%votes' => $votes)) .'</div>';
  }
  else {
    $output .= '<p class="message">'. t('No votes have been recorded for this poll.') .'</p>';
  }
  $output .= '</div>';
  return $output;
} 

function _advpoll_show_cancel_form($node) {
  $output = '';
  if ($node->voted && $node->cancel_vote && user_access('cancel own vote') && _advpoll_is_active($node)) {
    $output .= drupal_get_form('advpoll_cancel_form', $node->nid);
  }
  return $output;
}

function theme_advpoll_bar($title, $percentage, $votes) {
  $output  = '<div class="text">'. $title .'</div>';
  $output .= '<div class="bar"><div style="width: '. $percentage .'%;" class="foreground"></div></div>';
  $output .= '<div class="percent">'. $percentage .'% <span class="votes">('. $votes .')</span></div>';
  return $output;
}

/**
 * Callback for 'results' tab for advpoll you can vote on.
 */
function advpoll_results() {
  if ($node = node_load(arg(1))) {
    drupal_set_title(check_plain($node->title));
    return node_show($node, 0);
  }
  else {
    // The url does not provide the appropriate node id
    drupal_not_found();
  }
}

function _advpoll_vote_response($node, $form_values) {
  $msg = t('Your vote was registered.');
  // Ajax response
  if ($form_values['ajax']) {
    list($node->voted, $node->cancel_vote) = _advpoll_user_voted($node->nid);
    $ajax_output .= advpoll_view_results($node, NULL, NULL);
    // Remove linebreaks as they will break jQuery's insert-HTML methods
    $ajax_output = str_replace("\n", '', $ajax_output);
    drupal_set_header('Content-Type: text/plain; charset=utf-8');
    print drupal_to_js(array('statusMsgs' => '<div class="messages status">'. $msg .'</div>', 'response' => $ajax_output));
    exit();
  }
  // Usual response
  else {
    drupal_set_message($msg);
  }
}

/**
 * Show results of the vote.
 *
 * This calls the appropriate vote results function, depending on the
 * mode. It will call advpoll_view_results_$mode, similarly to
 * advpoll_view_voting().
 */
function advpoll_view_results(&$node, $teaser, $page) {
  $mode = _advpoll_get_mode($node->type);
  if (_advpoll_can_view_results($node)) {
    if (function_exists("advpoll_view_results_$mode")) {
      $results = call_user_func("advpoll_view_results_$mode", $node, $teaser, $page);
      $output .= theme('advpoll_results', check_plain($node->title),
        $results['results'], $results['votes'], $node->links, $node->nid, $node->voted, $node->cancel_vote);
    }
  }
  $output .= _advpoll_show_cancel_form($node);
  return $output;
}

/**
 * Callback for canceling a vote.
 */
function advpoll_cancel($nid) {
  global $user;
  $nid = arg(2);
  if ($node = node_load(array('nid' => $nid))) {
    if ($node->voted && _advpoll_is_active($node)) {
      if ($user->uid && count(votingapi_get_user_votes('advpoll', $node->nid)) > 0) {
        votingapi_unset_vote('advpoll', $node->nid, $user->uid);
      }
      else {
        $host = $_SERVER['HTTP_X_FORWARDED_FOR']? $_SERVER['HTTP_X_FORWARDED_FOR'] : $_SERVER['REMOTE_ADDR'];
        db_query("DELETE FROM {votingapi_vote} WHERE content_id=%d and hostname = '%s' AND uid=0", $node->nid, $host);
        votingapi_recalculate_results('advpoll', $nid);
      }
      drupal_set_message(t('Your vote was canceled.'));
    }
    else {
      drupal_set_message(t("You are not allowed to cancel an invalid choice."), 'error');
    }
    drupal_goto('node/'. $nid);
   }  
  else {
    drupal_not_found();
  }
}

/**
 * Check if user is eligible to vote in this poll.
 */
function advpoll_eligible($node, $uid = NULL) {
  global $user;
  if (!isset($uid)) {
    $uid = $user->uid;
  }

  if ($node->uselist) {
    $can_vote = db_fetch_object(db_query("SELECT COUNT(*) AS eligible FROM {advpoll_electoral_list} WHERE nid=%d AND uid=%d", $node->nid, $uid));
    $eligible = $can_vote->eligible;
  }
  else {
    $eligible = user_access('vote on polls');
  }
  return $eligible;
}

function advpoll_algorithms($mode) {
  return call_user_func("advpoll_algorithms_$mode");
}

/**
 * Load the available modes.
 *
 * This scans the modes subdirectory to find mode.inc files, where
 * mode is considered to be the mode name. Found files are loaded and
 * added to the mode list.
 */
function _advpoll_list_modes() {
  static $_advpoll_modes;
  if (!$_advpoll_modes) {
    foreach (file_scan_directory(dirname(__FILE__) .'/modes/',
        '^([^\.].*)\.inc$', array('.', '..', 'CVS'), 0, FALSE) as $file) {
      require_once($file->filename);
      $mode = $file->name;
      if (function_exists("advpoll_info_$mode")) {
        $_advpoll_modes[$mode] = call_user_func("advpoll_info_$mode");
      }
    }
  }
  return $_advpoll_modes;
}

/**
 * Helper function for rich text in choices.
 *  
 * We strip out the paragraphs which are not allowed within the label element
 * and created by check_markup() when "Line break converter"-filter is used.
 */
function _advpoll_choice_markup($text, $format = FILTER_FORMAT_DEFAULT, $check = true) {
  $text = check_markup($text, $format, $check);
  $text = str_replace(array('<p>', '</p>'), '', $text);
  $text = trim($text);

  return $text; 
}

/**
 * Wrapper function around form_set_error() to support validating of Ajax voting.
 */
function _advpoll_form_set_error($name = NULL, $message = '', $ajax = false) {
  if ($ajax) {
    drupal_set_header('Content-Type: text/plain; charset=utf-8');
    print drupal_to_js(array('errors' => '<div class="messages error">'. $message .'</div>'));
    exit;
  }
  else {
    return form_set_error('choice[', $message);
  }
}
